package main

/*
Update sets are sets of packages generated by Gemnasium, aim to be test
in projects to determine if updates are going to pass.
These functions are meant to be used during CI tests.
*/

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"os/exec"
	"path"
	"strings"
	"time"
)

const (
	ENV_GEMNASIUM_TESTSUITE          = "GEMNASIUM_TESTSUITE"
	ENV_GEMNASIUM_BUNDLE_UPDATE_CMD  = "GEMNASIUM_BUNDLE_UPDATE_CMD"
	ENV_GEMNASIUM_BUNDLE_INSTALL_CMD = "GEMNASIUM_BUNDLE_INSTALL_CMD"
	ENV_BRANCH                       = "BRANCH"
	ENV_REVISION                     = "REVISION"
	AUTOUPDATE_MAX_DURATION          = 1800
	BUNDLE_INSTALL_CMD               = "bundle install"
	BUNDLE_UPDATE_CMD                = "bundle update"
	UPDATE_SET_SUCCESS               = "succeeded"
	UPDATE_SET_FAIL                  = "failed"
)

type RequirementUpdate struct {
	File  DependencyFile `json:"file"`
	Patch string         `json:"patch"`
}

type VersionUpdate struct {
	Package       Package
	OldVersion    string `json:"old_version"`
	TargetVersion string `json:"target_version"`
}

type UpdateSet struct {
	ID                 int                 `json:"id"`
	RequirementUpdates []RequirementUpdate `json:"requirement_updates"`
	VersionUpdates     []VersionUpdate     `json:"version_updates"`
}

type UpdateSetResult struct {
	UpdateSetID     int              `json:"-"`
	ProjectSlug     string           `json:"-"`
	Status          string           `json:"status"`
	DependencyFiles []DependencyFile `json:"dependency_files"`
}

// Download and loop over update sets, apply changes, run test suite, and finally notify gemnasium
func AutoUpdate(projectSlug string, testSuite []string, config *Config) error {
	if projectSlug == "" {
		return errors.New("Arg [projectSlug] can't be empty")
	}
	if envTS := os.Getenv(ENV_GEMNASIUM_TESTSUITE); envTS != "" {
		testSuite = []string{os.Getenv(ENV_GEMNASIUM_TESTSUITE)}
	}
	if len(testSuite) == 0 {
		return errors.New("Arg [testSuite] can't be empty")
	}

	fmt.Printf("Executing test script: ")
	out, err := executeTestSuite(testSuite)
	if err != nil {
		fmt.Println("Aborting, initial test suite run is failing:")
		fmt.Printf("%s\n", out)
		return err
	}

	// We'll be checking loop duration on each iteration
	startTime := time.Now()
	// Loop until tests are green
	for {
		if time.Since(startTime).Seconds() > AUTOUPDATE_MAX_DURATION {
			fmt.Println("Max loop duration reached, aborting.")
			break
		}
		updateSet, err := fetchUpdateSet(projectSlug, config)
		if err != nil {
			return err
		}
		if updateSet.ID == 0 {
			fmt.Println("Job done!")
			break
		}
		fmt.Printf("\n========= [UpdateSet #%d] =========\n", updateSet.ID)

		// We have an updateSet, let's patch files and run tests
		// We need to keep a list of updated files to restore them after this run
		orgDepFiles, uptDepFiles, err := applyUpdateSet(updateSet)
		if err != nil {
			return err
		}

		out, err := executeTestSuite(testSuite)
		resultSet := &UpdateSetResult{UpdateSetID: updateSet.ID, ProjectSlug: projectSlug, DependencyFiles: uptDepFiles}
		if err == nil {
			// we found a valid candidate, ending.
			resultSet.Status = UPDATE_SET_SUCCESS
			err := pushUpdateSetResult(resultSet, config)
			if err != nil {
				return err
			}
			break
		}
		// display cmd output
		fmt.Printf("%s\n", out)
		resultSet.Status = UPDATE_SET_FAIL
		err = pushUpdateSetResult(resultSet, config)
		if err != nil {
			return err
		}
		err = restoreDepFiles(orgDepFiles)
		if err != nil {
			return err
		}

		// Let's continue with another set
	}
	return nil
}

// Fetch an update set and apply it
func fetchUpdateSet(projectSlug string, config *Config) (*UpdateSet, error) {
	client := &http.Client{}
	url := fmt.Sprintf("%s/projects/%s/branches/%s/update_sets/next", config.APIEndpoint, projectSlug, getCurrentBranch())
	revision := getCurrentRevision()
	if revision == "" {
		return nil, errors.New("Can't determine current revision, please use REVISION env var to specify it")
	}
	revisionJSON, err := json.Marshal(&map[string]string{"revision": revision})
	if err != nil {
		return nil, err
	}

	req, err := NewAPIRequest("POST", url, config.APIKey, bytes.NewReader(revisionJSON))
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("Server returned non-200 status: %v\n", resp.Status)
	}

	var updateSet *UpdateSet
	if err := json.Unmarshal(body, &updateSet); err != nil {
		fmt.Printf("body: %s\n", body)
		return nil, err
	}

	// if RawFormat flag is set, don't format the output
	if config.RawFormat {
		fmt.Printf("%s", body)
	}
	return updateSet, nil
}

// Patch files if needed, and update packages
// Will return a slice of original files and a slice of the updated files, with
// their content
func applyUpdateSet(updateSet *UpdateSet) (orgDepFiles, uptDepFiles []DependencyFile, err error) {
	orgDepFiles = make([]DependencyFile, len(updateSet.RequirementUpdates))
	uptDepFiles = make([]DependencyFile, len(updateSet.RequirementUpdates))
	GemfileLock := NewDependencyFile("Gemfile.lock")
	for i, ru := range updateSet.RequirementUpdates {
		f := ru.File
		err = f.CheckFileSHA1()
		if err != nil {
			return orgDepFiles, uptDepFiles, err
		}
		// fetch file content
		f.Update()
		orgDepFiles[i] = f
		fmt.Println("Patching", f.Path)
		err := f.Patch(ru.Patch)
		if err != nil {
			return orgDepFiles, uptDepFiles, err
		}
		uptDepFiles[i] = f
		// TODO: Make this command generic
		bi := BUNDLE_INSTALL_CMD
		if biCMDEnv := os.Getenv(ENV_GEMNASIUM_BUNDLE_INSTALL_CMD); biCMDEnv != "" {
			bi = biCMDEnv
		}
		parts := strings.Fields(bi)
		cmd := exec.Command(parts[0], parts[1:]...)
		cmd.Dir = path.Dir("f.Path")
		out, err := cmd.Output()
		if err != nil {
			fmt.Printf("Error while installing packages: %s", string(out))
			return orgDepFiles, uptDepFiles, err
		}
	}

	upt := BUNDLE_UPDATE_CMD
	if uptEnv := os.Getenv(ENV_GEMNASIUM_BUNDLE_UPDATE_CMD); uptEnv != "" {
		upt = uptEnv
	}
	parts := strings.Fields(upt)
	for _, vu := range updateSet.VersionUpdates {
		// TODO: run bundle update here
		fmt.Printf("Updating dependency %s (%s => %s)\n", vu.Package.Name, vu.OldVersion, vu.TargetVersion)
		parts = append(parts, vu.Package.Name)
	}
	fmt.Printf("Executing update commmand: %s\n", strings.Join(parts, " "))
	out, err := exec.Command(parts[0], parts[1:]...).Output()
	if err != nil {
		fmt.Printf("%s\n", out)
		return orgDepFiles, uptDepFiles, err
	}
	orgDepFiles = append(orgDepFiles, *GemfileLock)
	GemfileLock.Update()
	uptDepFiles = append(uptDepFiles, *GemfileLock)

	fmt.Println("Done")
	return orgDepFiles, uptDepFiles, nil
}

// Once update set has been tested, we must send the result to Gemnasium,
// in order to update statitics.
func pushUpdateSetResult(rs *UpdateSetResult, config *Config) error {
	fmt.Printf("Pushing result (status='%s'): ", rs.Status)
	if rs.UpdateSetID == 0 || rs.Status == "" {
		return errors.New("Missing updateSet ID and/or status args")
	}
	client := &http.Client{}
	url := fmt.Sprintf("%s/projects/%s/branches/%s/update_sets/%d", config.APIEndpoint, rs.ProjectSlug, getCurrentBranch(), rs.UpdateSetID)
	updateJSON, err := json.Marshal(rs)
	if err != nil {
		return err
	}

	req, err := NewAPIRequest("PATCH", url, config.APIKey, bytes.NewReader(updateJSON))
	if err != nil {
		return err
	}

	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("Server returned non-200 status: %v\n", resp.Status)
	}
	fmt.Printf("done\n")
	return nil
}

// Return the current branch name, using git.
// If the env var "BRANCH" is declared, its value is returned diretly
func getCurrentBranch() string {
	if envBranch := os.Getenv(ENV_BRANCH); envBranch != "" {
		return envBranch
	}
	out, err := exec.Command(gitPath(), "rev-parse", "--abbrev-ref", "HEAD").Output()
	if err != nil {
		return "master"
	}
	return strings.TrimSpace(string(out))
}

// return the current commit sha, using git
// If the env var "REVISION" is specified, its value is returned directly
func getCurrentRevision() string {
	if envRevision := os.Getenv(ENV_REVISION); envRevision != "" {
		return envRevision
	}
	out, err := exec.Command(gitPath(), "rev-parse", "--verify", "HEAD").Output()
	if err != nil {
		return ""
	}
	return strings.TrimSpace(string(out))
}

// Lookup for "git" in $PATH
func gitPath() string {
	path, _ := exec.LookPath("git")
	return path
}

// Restore original files.
// Needed after each run
func restoreDepFiles(dfiles []DependencyFile) error {
	fmt.Printf("%d file(s) to be restored.\n", len(dfiles))
	for _, df := range dfiles {
		fmt.Printf("Restoring file %s: ", df.Path)
		err := ioutil.WriteFile(df.Path, df.Content, 0644)
		if err != nil {
			return err
		}
		fmt.Printf("done\n")
	}
	return nil
}

func executeTestSuite(ts []string) ([]byte, error) {
	done := make(chan struct {
		Output []byte
		Err    error
	})
	defer close(done)
	var out []byte
	var err error
	fmt.Printf("Executing test script")
	start := time.Now()
	go func() {
		result, err := exec.Command(ts[0], ts[1:]...).Output()
		done <- struct {
			Output []byte
			Err    error
		}{result, err}
	}()
	var stop bool
	for {
		select {
		case result := <-done:
			stop = true
			out = result.Output
			err = result.Err
		default:
			fmt.Print(".")
			time.Sleep(1 * time.Second)
		}
		if stop {
			break
		}
	}
	fmt.Printf("done (%fs)\n", time.Since(start).Seconds())
	return out, err
}
