package main

/*
Update sets are sets of packages generated by Gemnasium, aim to be test
in projects to determine if updates are going to pass.
These functions are meant to be used during CI tests.
*/

import (
	"bytes"
	"crypto/sha1"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"os/exec"
	"path"
	"strings"
	"time"

	"github.com/sergi/go-diff/diffmatchpatch"
)

const (
	ENV_GEMNASIUM_TESTSUITE          = "GEMNASIUM_TESTSUITE"
	ENV_GEMNASIUM_BUNDLE_UPDATE_CMD  = "GEMNASIUM_BUNDLE_UPDATE_CMD"
	ENV_GEMNASIUM_BUNDLE_INSTALL_CMD = "GEMNASIUM_BUNDLE_INSTALL_CMD"
	ENV_BRANCH                       = "BRANCH"
	ENV_REVISION                     = "REVISION"
	AUTOUPDATE_MAX_DURATION          = 1800
	BUNDLE_INSTALL_CMD               = "bundle install"
	BUNDLE_UPDATE_CMD                = "bundle update"
	UPDATE_SET_SUCCESS               = "succeeded"
	UPDATE_SET_FAIL                  = "failed"
)

type RequirementUpdate struct {
	File  RequirementFile `json:"file"`
	Patch string          `json:"patch"`
}

type RequirementFile struct {
	Path string `json:"path"`
	SHA1 string `json:"sha1"`
}

type VersionUpdate struct {
	Package       Package
	OldVersion    string `json:"old_version"`
	TargetVersion string `json:"target_version"`
}

type UpdateSet struct {
	ID                 int                 `json:"id"`
	RequirementUpdates []RequirementUpdate `json:"requirement_updates"`
	VersionUpdates     []VersionUpdate     `json:"version_updates"`
}

// Download and loop over update sets, apply changes, run test suite, and finally notify gemnasium
func AutoUpdate(projectSlug string, testSuite []string, config *Config) error {
	if projectSlug == "" {
		return errors.New("Arg [projectSlug] can't be empty")
	}
	if envTS := os.Getenv(ENV_GEMNASIUM_TESTSUITE); envTS != "" {
		testSuite = []string{os.Getenv(ENV_GEMNASIUM_TESTSUITE)}
	}
	if len(testSuite) == 0 {
		return errors.New("Arg [testSuite] can't be empty")
	}

	fmt.Printf("Executing test script: ")
	start := time.Now()
	err := exec.Command(testSuite[0], testSuite[1:]...).Run()
	fmt.Printf("done (%fs)\n", time.Since(start).Seconds())
	if err != nil {
		fmt.Println("Aborting, initial test suite run is failing")
		return err
	}

	// We'll be checking loop duration on each iteration
	startTime := time.Now()
	// Loop until tests are green
	for {
		if time.Since(startTime).Seconds() > AUTOUPDATE_MAX_DURATION {
			fmt.Println("Max loop duration reached, aborting.")
			break
		}
		updateSet, err := fetchUpdateSet(projectSlug, config)
		if err != nil {
			return err
		}
		if updateSet.ID == 0 {
			fmt.Println("Job done!")
			break
		}
		fmt.Printf("========= [UpdateSet #%d] =========\n", updateSet.ID)

		// We have an updateSet, let's patch files and run tests
		err = applyUpdateSet(updateSet)
		if err != nil {
			return err
		}

		fmt.Printf("Executing test script: ")
		start := time.Now()
		err = exec.Command(testSuite[0], testSuite[1:]...).Run()
		fmt.Printf("done (%fs)\n", time.Since(start).Seconds())
		if err == nil {
			// we found a valid candidate, ending.
			err := pushUpdateSetResult(projectSlug, updateSet.ID, UPDATE_SET_SUCCESS, config)
			if err != nil {
				return err
			}

			break
		}
		err = pushUpdateSetResult(projectSlug, updateSet.ID, UPDATE_SET_FAIL, config)
		if err != nil {
			return err
		}
		// Let's continue with another set
	}
	return nil
}

// Fetch an update set and apply it
func fetchUpdateSet(projectSlug string, config *Config) (*UpdateSet, error) {
	client := &http.Client{}
	url := fmt.Sprintf("%s/projects/%s/branches/%s/update_sets/next", config.APIEndpoint, projectSlug, getCurrentBranch())
	revision := getCurrentRevision()
	if revision == "" {
		return nil, errors.New("Can't determine current revision, please use REVISION env var to specify it")
	}
	revisionJSON, err := json.Marshal(&map[string]string{"revision": revision})
	if err != nil {
		return nil, err
	}

	req, err := NewAPIRequest("POST", url, config.APIKey, bytes.NewReader(revisionJSON))
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("Server returned non-200 status: %v\n", resp.Status)
	}

	var updateSet *UpdateSet
	if err := json.Unmarshal(body, &updateSet); err != nil {
		fmt.Printf("body: %s\n", body)
		return nil, err
	}

	// if RawFormat flag is set, don't format the output
	if config.RawFormat {
		fmt.Printf("%s", body)
	}
	return updateSet, nil
}

// Patch files if needed, and update packages
func applyUpdateSet(updateSet *UpdateSet) error {
	for _, ru := range updateSet.RequirementUpdates {
		f := ru.File
		err := checkFileSHA1(f.Path, f.SHA1)
		if err != nil {
			return err
		}
		fmt.Println("Patching", f.Path)
		patchFile(f.Path, ru.Patch)
		// TODO: Make this command generic
		bi := BUNDLE_INSTALL_CMD
		if biCMDEnv := os.Getenv(ENV_GEMNASIUM_BUNDLE_INSTALL_CMD); biCMDEnv != "" {
			bi = biCMDEnv
		}
		parts := strings.Fields(bi)
		cmd := exec.Command(parts[0], parts[1:]...)
		cmd.Dir = path.Dir("f.Path")
		err = cmd.Run()
		if err != nil {
			return err
		}
	}

	upt := BUNDLE_UPDATE_CMD
	if uptEnv := os.Getenv(ENV_GEMNASIUM_BUNDLE_UPDATE_CMD); uptEnv != "" {
		upt = uptEnv
	}
	parts := strings.Fields(upt)
	for _, vu := range updateSet.VersionUpdates {
		// TODO: run bundle update here
		fmt.Printf("Updating dependency %s (%s => %s)\n", vu.Package.Name, vu.OldVersion, vu.TargetVersion)
		parts = append(parts, vu.Package.Name)
	}
	fmt.Printf("Executing update commmand: %s\n", strings.Join(parts, " "))
	err := exec.Command(parts[0], parts[1:]...).Run()
	if err != nil {
		return err
	}
	fmt.Println("Done")
	return nil
}

// Once update set has been tested, we must send the result to Gemnasium,
// in order to update statitics.
func pushUpdateSetResult(projectSlug string, updateSetID int, status string, config *Config) error {
	fmt.Printf("Pushing result (status='%s'): ", status)
	if updateSetID == 0 || status == "" {
		return errors.New("Missing updateSet ID and/or status args")
	}
	client := &http.Client{}
	url := fmt.Sprintf("%s/projects/%s/branches/%s/update_sets/%d", config.APIEndpoint, projectSlug, getCurrentBranch(), updateSetID)
	update := &map[string]string{"state": status}
	updateJSON, err := json.Marshal(update)
	if err != nil {
		return err
	}

	req, err := NewAPIRequest("PATCH", url, config.APIKey, bytes.NewReader(updateJSON))
	if err != nil {
		return err
	}

	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("Server returned non-200 status: %v\n", resp.Status)
	}
	fmt.Printf("done\n")
	return nil
}

func checkFileSHA1(filePath, fileSHA1 string) error {
	dat, err := ioutil.ReadFile(filePath)
	if err != nil {
		return err
	}
	h := sha1.New()
	header := fmt.Sprintf("blob %d\x00", len(dat))
	io.WriteString(h, header)
	io.Copy(h, bytes.NewReader(dat))
	hash := h.Sum(nil)

	sum := fmt.Sprintf("%x", hash)
	if sum != fileSHA1 {
		return fmt.Errorf("%s: File signature doesn't match (expected: %s, got: %s)", filePath, fileSHA1, sum)
	}
	return nil
}

// Return the current branch name, using git.
// If the env var "BRANCH" is declared, its value is returned diretly
func getCurrentBranch() string {
	if envBranch := os.Getenv(ENV_BRANCH); envBranch != "" {
		return envBranch
	}
	out, err := exec.Command(gitPath(), "rev-parse", "--abbrev-ref", "HEAD").Output()
	if err != nil {
		return "master"
	}
	return strings.TrimSpace(string(out))
}

// return the current commit sha, using git
// If the env var "REVISION" is specified, its value is returned directly
func getCurrentRevision() string {
	if envRevision := os.Getenv(ENV_REVISION); envRevision != "" {
		return envRevision
	}
	out, err := exec.Command(gitPath(), "rev-parse", "--verify", "HEAD").Output()
	if err != nil {
		return ""
	}
	return strings.TrimSpace(string(out))
}

// Lookup for "git" in $PATH
func gitPath() string {
	path, _ := exec.LookPath("git")
	return path
}

// Apply patch to a file.
// The file will be opened, updated, and written
func patchFile(filePath, patch string) error {
	dmp := diffmatchpatch.New()
	patches, err := dmp.PatchFromText(patch)
	if err != nil {
		return err
	}
	dat, err := ioutil.ReadFile(filePath)
	if err != nil {
		return err
	}

	var patchesApplied []bool
	patchedDat, patchesApplied := dmp.PatchApply(patches, string(dat))
	for i, applied := range patchesApplied {
		if !applied {
			return fmt.Errorf("Patching failed: %s", patches[i])
		}
	}
	fmt.Printf("%d patches applied\n", len(patchesApplied))
	err = ioutil.WriteFile(filePath, []byte(patchedDat), 0644)
	if err != nil {
		return err
	}
	return nil
}
